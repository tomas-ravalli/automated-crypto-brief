import os
import smtplib
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from email.message import EmailMessage
from email.utils import make_msgid
from coinbase.wallet.client import Client
from dotenv import load_dotenv
from datetime import date

# Load environment variables from .env file
load_dotenv()

# --- Configuration ---
COINBASE_API_KEY = os.getenv("COINBASE_API_KEY")
COINBASE_API_SECRET = os.getenv("COINBASE_API_SECRET")
SENDER_EMAIL = os.getenv("GMAIL_ADDRESS")
SENDER_PASSWORD = os.getenv("GMAIL_APP_PASSWORD")
RECIPIENT_EMAIL = os.getenv("RECIPIENT_EMAIL")
CURRENCY_PAIR = 'XRP-EUR'
PURCHASE_PRICES_STR = os.getenv("PURCHASE_PRICES")

def get_xrp_price():
    """Fetches the current XRP-EUR spot price from Coinbase."""
    try:
        client = Client(COINBASE_API_KEY, COINBASE_API_SECRET)
        price_data = client.get_spot_price(currency_pair=CURRENCY_PAIR)
        return float(price_data.amount)
    except Exception as e:
        print(f"Error fetching price: {e}")
        return None

def calculate_average_purchase_price(prices_str):
    """Calculates the simple average of purchase prices."""
    if not prices_str:
        return None
    try:
        prices = [float(p) for p in prices_str.strip().split(';') if p]
        return sum(prices) / len(prices) if prices else None
    except (ValueError, Exception) as e:
        print(f"Error processing prices: {e}")
        return None

def update_data_and_create_graph(today_str, return_pct):
    """
    Updates the historical data CSV and generates the performance graph.
    Returns the file path of the generated graph.
    """
    csv_file = 'historical_data.csv'
    
    # Create a new data entry with the return percentage rounded to two decimals
    new_data = pd.DataFrame([{
        'date': pd.to_datetime(today_str, dayfirst=True),
        'return_pct': round(return_pct, 2)  # <-- The change is here
    }])
    
    # Read existing data or create a new file
    if os.path.exists(csv_file):
        df = pd.read_csv(csv_file, parse_dates=['date'])
        df = pd.concat([df, new_data], ignore_index=True)
    else:
        df = new_data
    
    # Save updated data
    df.to_csv(csv_file, index=False)
    
    # --- Generate Graph ---
    # (The rest of the function remains the same)
    
    weekly_avg_return = df.set_index('date')['return_pct'].resample('W-SUN').mean().round(2)
    
    if len(weekly_avg_return) < 2:
        print("Not enough data to generate a meaningful graph. Skipping chart generation.")
        return None
        
    plt.style.use('default')
    fig, ax = plt.subplots(figsize=(15, 7))
    
    ax.plot(weekly_avg_return.index, weekly_avg_return, marker='o', linestyle='-', color='grey', markersize=4, label='Weekly Avg. Return')
    
    x_vals = mdates.date2num(weekly_avg_return.index)
    # Ensure no NaNs are passed to polyfit
    valid_points = weekly_avg_return.dropna()
    m, b = np.polyfit(mdates.date2num(valid_points.index), valid_points, 1)
    ax.plot(weekly_avg_return.index, m * x_vals + b, '--', color='#ff9999', label='Trend')

    ax.set_title('Weekly Average Return (%) (Mon-Sun)', fontsize=16)
    ax.set_ylabel('Average Return', fontsize=12)
    ax.grid(axis='y', linestyle='--', alpha=0.7)
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
    ax.axhline(0, color='grey', linewidth=0.8)
    
    y_min, y_max = weekly_avg_return.min(), weekly_avg_return.max()
    y_buffer = (y_max - y_min) * 0.1 if (y_max - y_min) > 0 else 1
    ax.set_ylim([y_min - y_buffer, y_max + y_buffer])
    ax.legend()
    
    graph_path = 'weekly_report_graph.png'
    plt.savefig(graph_path, bbox_inches='tight', pad_inches=0.2)
    plt.close()
    
    return graph_path

def send_email(current_price, avg_purchase_price, graph_path):
    """Sends an email with the price report and embedded graph."""
    if current_price is None or avg_purchase_price is None:
        print("Skipping email due to missing price data.")
        return

    # --- Calculations ---
    return_pct = ((current_price - avg_purchase_price) / avg_purchase_price) * 100
    profit_per_unit = current_price - avg_purchase_price
    return_multiplier = current_price / avg_purchase_price

    # --- Date Formatting ---
    today_str = date.today().strftime("%d/%m/%Y")
    
    # --- Email Setup ---
    msg = EmailMessage()
    msg['Subject'] = f'Daily {CURRENCY_PAIR} Report: {today_str}'
    msg['From'] = SENDER_EMAIL
    msg['To'] = RECIPIENT_EMAIL

    # --- Email Body Parts ---
    # Split the body into top and bottom sections for image placement
    body_top = f"""
Return: {return_pct:+.2f}%
Return Multiplier: x{return_multiplier:.2f}
Profit/Loss per Unit: ‚Ç¨{profit_per_unit:,.2f}

Current Price: ‚Ç¨{current_price:,.2f}
Avg. Purchase Price: ‚Ç¨{avg_purchase_price:,.2f}"""

    body_bottom = f"""
(Report generated by bot)
üåê ¬© 2025 t.r.
    """

    # Set the plain text content
    msg.set_content(f"{body_top}\n{body_bottom}")

    # --- HTML Body and Image Embedding ---
    if graph_path:
        image_cid = make_msgid(domain='t-ravalli-report')[1:-1]
        
        # Construct HTML with the image in the middle
        html_body = f"""
        <html>
          <body>
            <pre style="font-family: monospace;">{body_top}</pre>
            <br>
            <img src="cid:{image_cid}">
            <br>
            <pre style="font-family: monospace;">{body_bottom}</pre>
          </body>
        </html>
        """
        msg.add_alternative(html_body, subtype='html')
        
        with open(graph_path, 'rb') as f:
            img_data = f.read()
        # The index is now 1 because add_alternative was called
        msg.get_payload()[1].add_related(img_data, 'image', 'png', cid=f'<{image_cid}>')
    
    # --- Send Email ---
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(SENDER_EMAIL, SENDER_PASSWORD)
            smtp.send_message(msg)
        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")